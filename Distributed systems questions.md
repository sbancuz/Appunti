---
tags:
  - distributed_systems
---
### Describe the REST architectural style

The REST style is s way to build a client server application that communicates under HTTP/HTTPS via JSON messages. This is because REST only offers four methods for communication: PUT, POST, GET, DELETE; thus there isn't enough methods to build an entire application. The solution to this problem is to encode the signature and arguments of a function is a JSON message and send that through one of the four methods listed before. The other main point of REST is that only the client should hold the state of the connection, thus the server shall have no such concept. In reality a pure REST application is hard to implement and wouldn't really meet the needs of the users, for this reason usually the server will hold some information of the client in persistent storage like a database.

All the responses that the client receives can be specified to be cached.
### Describe name resolution in general and focus on the various approaches you know to resolve flat names.

Names are used to refer to entities in a system, there are two types of names: human friendly -- usually represented as strings -- and machine friendly - -represented as ips.  Name resolution stands for the process of converting a human friendly name to the actual address of the machine. Name resolution can happen in three main methods: flat naming, structured naming and attribute based naming.

In flat naming every machine has it's own name, usually without any meaning or structure to it represented with a string. There are various versions for resolution of flat names, for simple solutions like home networks we can just broadcast the network or in some cases even use multicast to find the device. To handle mobile devices we can use forwarding pointers that transfer the reference of the device between routers when in motion. There are also home based approaches that works by having a "home server" and when a client needs to find another node in the network, it can just contact this server that know where everybody is, the problem with this approach is that the server location is fixed, so requests may have to travel a lot even if the two devices are not very far from one another. An extension of a home based approach is to use a dth that divides the network into various subnetworks and knows the address of everybody in it's own network, if a client needs to communicate with someone outside the network, the request will navigate between the various dth s until it finds the desired network and then it gets to the receiver. As a last technique we have hierarchical naming, with this approach the names have some structure and are organized as a tree like a directory in a file system, and every non leaf node knows of every children node, this has obvious bad implications, in fact the top level root node has information about every node in the network.
### Describe leader election protocols and compare them in terms of assumptions and number of messages required to end the election

In a distributed system leader election can happen in two ways: bully election and ring based. Both of these protocol require a reliable connection and a unique id that distinguishes them from every other node. Also we have to treat the system as if it was a synchronous one, so recognizing that someone has crashed needs to be possible.

The bully election protocol works by trying to elect the highest id node in the network as a leader, this happens in a few steps: first a node has to notice that a node is unresponsive, that the same node will try to contact every other node that it knows has higher id that them and waits for a response. If it receives no response then it will assume that it's the new leader of the network and send a new message notifying every other node of this change. 
In contrast the ring based protocol it arranges the nodes in a logical loop and still tries to elect a new leader with highest id. When a process notices that the leader is non respondent, it will send a message containing its id to the next node in the chain, if a node doesn't respond then it will try the next one and so on, then the receiver will add it's own id to the message and pass it along. If a node receives a message containing it's own id, then it will select the highest id node and pass the information along to all the nodes.
### Consider the MapReduce programming model and the execution framework:

1) Explain the programming primitives that the model offers.
	The model offers a two primitives: a map function that represents a pure function that applies a functor to some data, and then it returns the result, and the reduce that takes as input the list of result of the map computation and applies a "reducing" function to it then returning only a single result.
	
2) Exemplify these programming primitives using a word/count application that takes in input some documents and outputs the number of occurrences of each word appearing in the documents.
	In this kind of system we can view the word counting function as the map function that takes in input a file and then it will return a map that connects every word with its number of occurrences. Then we can view the reduce as the operation that takes in all the various maps, given as a result of every computation of every file, and it will combine them all into one
	
3) Explain how the execution framework handles data parallelism, data locality, fault tolerance and stragglers.
	Each computation can be done in parallel since the function that both the map and the reduce use are pure, this means that the result of their computation depends only on their input. This property makes the system massively parallelizable. But when having such a parallel application we have to think about the data locality, because transfer speeds are usually much slower than any computation, this imposes a limit on how distant data can be from one another, usually data is contained in the same data center or even in the same rack. To handle all this processes we use a node that act as a master that checks if some nodes are slower or even crash, if they are slower than others they are called stragglers and they will be given less amount of work, this is because if they had the same amount of work as some other node the whole computation will be limited just by the speed of this node. The objective of the master is also to find the crashes in the system, in one is detected then the master will ask to redo all the work to some other node, if by any chance the node that has been considered crashes responds with a result, the message will be ignored.
### Describe the following three approaches for search and lookup in a p2p network. Compare them in terms of state maintained at each node, search expressivity, search scope, guarantees of lookup success, resilience to network dynamicity (joins and leaves of nodes)

-  Centralized table (e.g. Napster)
	When there is a centralized table there is a node in the network that holds the location of every other node in the network and what each node is posting. Each node will only hold information regarding the location of the central table and what resources it makes available. A node can easily search for a resource in the entire network just by asking the central directory if it holds the reference to a node that provides it, so there are no guarantees of success. New nodes to subscribe to a network, a new node just has to contact the central server that will respond with the list of the documents that the network offers.

- Flooding (e.g. Gnutella)
	In query flooding there is no concept of a centralized or semi centralized resource that holds information about the system, to find a resource you have to ask to every node you can reach and if they don't have it, they will forward the request to each of their peers. This method is extremely wasteful and does not guarantee anything about whether or not a resource is available on the network, to find out you have to ask everyone. This approach is also very sensible of network dynamicity because if a node leaves it can divide the network in two separate network without no one noticing, though this eventuality is quite unlikely in a big network since when a node tries to connect, it has to inform every node on the network and the most free one will establish a connection between them. The probability of accepting a connection is inversely proportional to the number of active connections.
 
- Distributed Hash Table (DHT, e.g. Chord)
	Chord is a middle ground with the centralized hash table approach and the query flooding one. There isn't only a central node that holds the references of all nodes in the network, but there are multiple tables that divide the network based on the hash of the resource they offer. Each table holds the position of every other table in the network. When entering this network a client just needs to contact a node that will lead it to the right hash table to register to the network. When searching one needs to contact a dth based on the computed hash of the search and ask it if it holds the resource, if the resource isn't available then we are sure that is not available in the entire system.
### Describe the various mobile code paradigms and the type of technologies that support them? Which paradigm is the most complex to implement? Why?

There are four types of mobile code paradigms: client server -- where the client makes a request to the server and then the server will respond with some kind of result, all the computation will happen in the server and the client doesn't know how the result is produced -- this type architecture is used in most web application and api; remote evaluation -- where the client tells the server what operation it should execute then the server will reply with the result -- that is used to offload computation like in a scientific environment; code on demand -- where the client will ask the server how it should handle a computation, the server will respond with the actual code -- and is mostly used by web browsers that download javascript bundles that will run on the client; and lastly mobile agent -- a client will create a connection with a server and use it's resources as if it was using its own, all the result will remain on the server; The more a system is mobile, the more complex it is to implement, this means that the mobile agent is the most complex to maintain of them all, preceded by remote evaluation, code on demand and client server in order.