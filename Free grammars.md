---
tags:
  - compilers
---
[[Regular expressions]] are simple cases of grammars. In fact regexes cannot represent every language, because in order to define a language, one can use rules that, after repeated application, allow to generate all and only the phrases of the language. This set of rules is called a generative grammar. 

The symbols that represent a grammar are:
- **axioms** -> they define the whole language phrase (this doesn't use strings but just phrases)
- **phrases** -> they define the phrase components

Two grammars are considered equals only if they generate the same language.
### Derivation chain
In order to represent the 'creation' of a phrase of a grammar we use a derivation chain that represents the steps took to represent it.

>[!note] Example
>Take for example a grammar that creates palindromes
>$$
\begin{cases}
L = \{ uu^{R} | u \in \{ a,b \}^{*}) \} \\
f \to \epsilon \\
f \to a f a \\
f \to b f b
\end{cases}
>$$
>A valid chain capable of spelling *abba* is $f \to a f a\to abfba \to a b \epsilon b a \to a b b a$

The language generated by starting from a specific non-terminal "A" is $L_{A}(G)$. Also if a phrase contains only terminal characters it is called **sential**
### Backus Normal Form

In order to write grammars we use **BNF** that is composed by four entities
- $V$ -> The non-terminal alphabet like the $f$ above
- $S \in V$ -> A particular non-terminal symbol called **axiom**
- $\Sigma$ -> Is the terminal alphabet or the set of characters that constitutes the phrase
- $P$ -> Is the sets of syntactic rules

>[!warning]
>In order to avoid confusion:
>- metasymbols ("$\to$", " | ", $\dots$) cannot be redifined
>- $V \cup \Sigma = \emptyset$

![[grammar.png]]

### Reduced form

To ensure that every non terminal is defined and that it actually meaningfully contributes to the definition of a language we can define a reduced form from three rules:
- Every non-terminal $A$ is reachable from the axiom
- Every non-terminal $A$ generates a non-empty set of strings
- The grammar may not have inessential circular derivations

This can be achieved through [[Algorithm for reduced BNF]]. Reduced forms however doesn't prohibit redundancy 